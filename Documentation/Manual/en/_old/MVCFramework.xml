<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns52="http://www.w3.org/1998/Math/MathML"
         xmlns:ns5="http://www.w3.org/1999/xlink"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>MVC Framework</title>

  <section>
    <title>Introduction</title>

    <section>
      <title>Model-View-Controller</title>

      <para>In the design of FLOW3's architecture we have taken great care to
      separate concerns and assign each part of the framework with
      well-defined tasks. The separation of concerns is an important principle
      of good software design and its most prominent representative probably
      is the Model-View-Controller pattern. MVC separates the business logic
      from the presentation by splitting up user interaction into three
      roles:</para>

      <itemizedlist>
        <listitem>
          <para>The <emphasis>model</emphasis> is an object which contains
          data and business logic of a certain domain. It doesn't contain any
          information about the presentation of that data, but rather defines
          the behaviour. In the FLOW3 project we prefer a special kind of
          model, the <link
          ns5:href="http://martinfowler.com/eaaCatalog/domainModel.html">Domain
          Model</link>.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>view</emphasis> represents the display of the
          model on the web or another output channel. Views only display data,
          they don't build or modify it.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>controller</emphasis> reacts on user input,
          selects and manipulates the model as accordingly, selects a view and
          passes it the prepared model for rendering.</para>
        </listitem>
      </itemizedlist>

      <para>This diagram outlines the collaboration between model, view and
      controller:</para>

      <figure>
        <title>Model-View-Controller Pattern</title>

        <mediaobject>
          <imageobject>
            <imagedata contentdepth="100%"
                       fileref="MVCFramework_ModelViewController.png"
                       scalefit="1" width="100%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Other Patterns Used</title>

      <para>Design Patterns (and MVC is one of them) are not only great for
      solving reoccuring design problems in a structured manner - they also
      help you communicating software designs. The following patterns play an
      important role in FLOW3's MVC mechanism and might give you a better idea
      of the overall design:</para>

      <itemizedlist>
        <listitem>
          <para>Incoming requests are handled by a Request Handler which takes
          the role of a <link ns5:href="???">Front Controller</link>.</para>
        </listitem>

        <listitem>
          <para><link ns5:href="???">Template View</link> is the most commonly
          used pattern for views, but <link ns5:href="???">Transform
          Views</link> and <link ns5:href="???">Two-Step Views</link> are
          equally supported.</para>
        </listitem>

        <listitem>
          <para>The preferred type of model is the <link ns5:href="???">Domain
          Model</link>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Hello World!</title>

      <para>Let's start with an example before we go into greater detail of
      request handling and the internals of the MVC framework. The minimal
      approach is to create an Action Controller which just returns
      <quote>Hello World!</quote>. To begin with, we need to create some
      directories which contain the code of our FLOW3 package and eventually
      the controller class:</para>

      <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        DefaultController.php</literallayout>

      <para>The DefaultController class looks as simple as this (leaving out
      the very recommended comments):</para>

      <example>
        <title>Hello World! controller</title>

        <programlisting language="PHP">namespace F3\Demo\Controller;

class DefaultController extends \F3\FLOW3\MVC\Controller\ActionController {
   public function indexAction() {
      return "Hello World!";
   }
}</programlisting>
      </example>

      <para>Provided that the document root of your local server points to
      FLOW3's <filename>Public/</filename> directory, you will get the
      following output when calling the URI
      <uri>http://localhost/demo/</uri>:</para>

      <screen>Hello World!</screen>

      <para>Great, that was easy - but didn't we say that it's the view's
      responsibility to take care of the presentation? Let's create a simple
      PHP-based view for that purpose:</para>

      <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        DefaultController.php
      View/
        DefaultIndex.php</literallayout>

      <para>The view's code is equally trivial:</para>

      <example>
        <title>Hello World! view</title>

        <programlisting language="php">namespace F3\Demo\View;

class DefaultIndex extends \F3\FLOW3\MVC\View\AbstractView {
   public function render() {
      return "Hello World!";
   }
}</programlisting>
      </example>

      <para>Finally our action controller needs a little tweak to return the
      rendered view instead of shouting <quote>Hello World!</quote>
      itself:</para>

      <example>
        <title>Improved Hello World! controller</title>

        <programlisting language="php">namespace F3\Demo\Controller;

class DefaultController extends \F3\FLOW3\MVC\Controller\ActionController {
   public function indexAction() {
      return $this-&gt;view-&gt;render();
   }
}</programlisting>
      </example>
    </section>

    <section>
      <title>Recommended File Structure</title>

      <para>As you have seen in the hello world example, conventions for the
      directory layout simplify your development a lot. There's no need to
      register controllers, actions or views if you follow our recommended
      file structure. These are the rules:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Controllers</emphasis> are located in their own
          directory <filename>Controller</filename> just below the
          <filename>Classes</filename> directory of your package. They can
          have arbitrary names while the
          <classname>DefaultController</classname> has a special meaning: If
          the package was specified in the request but no controller, the
          <classname>DefaultController</classname> will be used.</para>
        </listitem>

        <listitem>
          <para><emphasis>View</emphasis> classes are situated below a
          <filename>View</filename> directory. The classname of the view is a
          combination of the name of the controller and the name of the
          action.</para>
        </listitem>
      </itemizedlist>

      <para>This sample directory layout demonstrates the above rules:</para>

      <example>
        <title>Sample file structure</title>

        <literallayout>Packages/
  Demo/
    Classes/
      Controller/
        DefaultController.php
        CustomerController.php
        OrderController.php
      View/
        DefaultIndex.php
        CustomerIndex.php
        CustomerList.php
        CustomerDetails.php
        OrderList.php</literallayout>
      </example>

      <para>Adhering to these conventions has the advantage that the classname
      of the view for example is resolved automatically. However it is
      possible (and not really difficult) to deviate from this layout and have
      a completely different structure.</para>
    </section>

    <section>
      <title>From the URI to the view</title>

      <caution>
        <para>For the example URIs we assume that the web root directory of
        your local server points to FLOW3's <filename>public/</filename>
        directory. If that's not the case you have to extend the URI
        accordingly.</para>
      </caution>

      <para>FLOW3 provides a standard way of resolving the URI to your
      MVC-Objects.</para>

      <para>Say, you want to see the list of customers (based on the
      file-structure-example above). The URI to get the list would be:
      <uri>http://localhost/demo/customer/list.html</uri> or just
      <uri>http://localhost/demo/customer/list</uri>.</para>

      <para>This URI will be resolved into the package-name
      (<emphasis>Demo</emphasis>), controller-name
      (<emphasis>Customer</emphasis>), action-name(<emphasis>list</emphasis>)
      and format-name (<emphasis>html</emphasis> - which is the default
      format).</para>

      <para>Depending on that, the controller
      <classname>\F3\Demo\Controller\CustomerController</classname> (Pattern:
      '<code>F3\@package\Controller\@controllerController'</code>) and its
      method <methodname>listAction()</methodname> will be used. The
      corresponding view is <classname>\F3\Demo\View\CustomerList</classname>
      (Pattern:
      <code>'F3\@package\View\@controller@action@format'</code>).</para>

      <para>If you have a look at the view pattern, you see, that you can
      easily add a view that creates an xml-output by creating the class
      <classname>\F3\Demo\View\CustomerListXML</classname>. You will get the
      xml-output by calling the URI
      <uri>http://localhost/demo/customer/list.xml</uri>.</para>
    </section>
  </section>

  <section>
    <title>Request and Response</title>

    <para>No matter if a FLOW3 application runs in a web context or is
    launched from the command line, the basic workflow is always the same: The
    user request is analyzed and forwarded to an appropriate controller which
    decides on which actions to take and finally returns a response which is
    handed over to the user. This section highlights the flow and the
    collaborators in the request-response machinery.</para>

    <section>
      <title>Request Processing Overview</title>

      <para>A sequence diagram is worth a thousand words said my grandma, so
      let's take a look at the standard request-response workflow in
      FLOW3:</para>

      <figure>
        <title>Example of a Web Request-Response Workflow</title>

        <mediaobject>
          <imageobject>
            <imagedata contentdepth="100%"
                       fileref="MVCFramework_RequestResponseWorkflow.png"
                       scalefit="1" width="100%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>As you see, there are a lot of parts of the framework involved for
      answering a request - and the diagram doesn't even consider caching or
      forwarding of requests. But we didn't create this structure just for the
      fun of it - each object plays an important role as you'll see in the
      next sections.</para>
    </section>

    <section>
      <title>Request Handler</title>

      <para>The request handler takes the important task to handle and respond
      to a request. There exists exactly one request handler for each request
      type. By default web and command line requests are supported, but more
      specialized request handlers can be developed, too.</para>

      <para>Before one of the request handlers comes to play, the framework
      needs to determine which of them is the most suitable for the current
      request. The request handler resolver asks all of the registered request
      handlers to rate on a scale how well they can handle the current raw
      request. The resolver then chooses the request handler with the most
      points and passes over the control.</para>

      <para>Custom request handlers for special purposes just need to
      implement the
      <interfacename>\F3\FLOW3\MVC\RequestHandlerInterface</interfacename>.
      All classes implementing that interface are automatically registered and
      will be considered while resolving a suitable request handler.</para>
    </section>

    <section>
      <title>Request Builder</title>

      <para>When a request handler receives a raw request, it needs to build a
      request object which can be passed to the dispatcher and later to the
      controller. The request building delegated to a request builder which
      can build the required request type (ie. web, CLI etc.).</para>

      <para>The building process mainly consists of</para>

      <procedure>
        <step>
          <para>create a new request object</para>
        </step>

        <step>
          <para>set some request-type specific parameters (like the request
          URI for a web request)</para>
        </step>

        <step>
          <para>determine and set the responsible controller, action and
          action arguments</para>
        </step>
      </procedure>

      <para>Especially the last step is important and requires some more or
      less complex routing in case of web requests.</para>
    </section>

    <section>
      <title>Request Processors</title>

      <para>Requests which were built by the request builder usually fit the
      most common needs. For special demands it is possible to postprocess the
      request object before it is sent to the dispatcher. Request processors
      can be registered through the Request Processor Chain Manager and are -
      as the name suggests - invoked in a chain.</para>
    </section>

    <section>
      <title>Request Dispatcher</title>

      <para>The final task of the MVC framework consists in dispatching the
      request to the controller specified in the request object. The request
      dispatcher will try to call the action specified in the request object
      and if none was specified fall back on a default action.</para>

      <note>
        <para>There are more features planned for the dispatcher, but at the
        time of this writing they have not yet been implemented.</para>
      </note>
    </section>

    <section>
      <title>Request Types</title>

      <para>FLOW3 supports the most important request types out of the box.
      Additional request types can easily be implemented by extending the
      <classname>\F3\FLOW3\MVC\Request</classname> class and registering a
      request handling which can handle the new request type (and takes care
      of building the request object). Here are the request types which come
      with the default FLOW3 distribution:</para>

      <section>
        <title>Web Request / Response</title>

        <para>Web requests are the most common request types. Currently only
        the basic features are implemented, but further options - especially
        for the web response - are in the pipeline.</para>
      </section>

      <section>
        <title>CLI Request / Response</title>

        <para>Requests from the command line are recognized by the used SAPI
        (Server Application Programming Interface). This request type is
        basically the same as the generic request type and mainly exists as a
        marker.</para>
      </section>

      <section>
        <title>AJAX Request / Response</title>

        <note>
          <para>This request type has not yet been implemented</para>
        </note>
      </section>
    </section>
  </section>

  <section>
    <title>Controller</title>

    <para></para>

    <section>
      <title>Action Controller</title>

      <para>Setting $this-&gt;viewObjectName to a view object name overrides
      the automatic resolving of the view name. Can be used for definining a
      standard view, for example \F3\Fluid\View\TemplateView.</para>

      <para></para>

      <section>
        <title>Initialization Methods</title>

        <para>initializeController</para>

        <para>initializeAction</para>

        <para>initializeView</para>
      </section>

      <section>
        <title>Configuration</title>

        <para></para>
      </section>

      <section>
        <title>Supported Request Types</title>

        <para></para>
      </section>

      <section>
        <title>Arguments</title>

        <para></para>
      </section>

      <section>
        <title>Action Methods</title>

        <para>$this-&gt;indexActionMethodName</para>

        <para></para>
      </section>

      <section>
        <title>Action View</title>

        <para>- $this-&gt;initializeView = TRUE | FALSE</para>
      </section>
    </section>

    <section>
      <title>Other Controllers</title>

      <section>
        <title>Abstract Controller</title>

        <para></para>
      </section>

      <section>
        <title>Request Handling Controller</title>

        <para></para>
      </section>

      <section>
        <title>Default Controller</title>

        <para></para>
      </section>

      <section>
        <title>Not Found Controller</title>

        <para>The
        <classname>F3\FLOW3\MVC\Controller\NotFoundController</classname> is
        used whenever no other controller could be resolved which would match
        the current request. It displays a generic "404 Page Not Found"
        message.</para>

        <para>It is possible to define your own custom controller which is
        used in these cases. Just specify the object name in the FLOW3
        settings.</para>
      </section>
    </section>
  </section>

  <section>
    <title>View</title>

    <para></para>

    <section>
      <title>Template View</title>

      <para></para>
    </section>

    <section>
      <title>Special Views</title>

      <section>
        <title>Default View</title>

        <para></para>
      </section>

      <section>
        <title>Empty View</title>

        <para></para>
      </section>
    </section>
  </section>

  <section>
    <title>Helpers</title>

    <para></para>
  </section>

  <section>
    <title>Model</title>

    <para></para>
  </section>

  <section>
    <title>Routing</title>

    <para></para>
  </section>

  <section>
    <title>CLI request handling</title>

    <para>FLOW3's CLI request handling offers a comfortable and flexible way
    of calling code from the command line:</para>

    <para><command>php index.php [<replaceable>command</replaceable>]
    [<replaceable>options</replaceable>] [--]
    [<replaceable>arguments</replaceable>]</command></para>

    <para><replaceable>command</replaceable>,
    <replaceable>options</replaceable> and
    <replaceable>arguments</replaceable> are optional, with varying results.
    The command structure follows what is commonly accpeted on unixoid systems
    for CLI programs:<variablelist>
        <varlistentry>
          <term>command</term>

          <listitem>
            <para>If not given, the default controller of the FLOW3 package is
            used and it's index action is called. While this is an allowed
            call, it hardly makes sense (other than checking if FLOW basically
            works). If command is given then it is defined as
            <emphasis><replaceable>package</replaceable>
            [[<replaceable>sub1..N</replaceable>]
            <replaceable>controller</replaceable>
            <replaceable>action</replaceable>]</emphasis></para>

            <para>First part is always the package. If only the package is
            given, it's default controller's index action is called.</para>

            <para>If at least three command parts are given, the last two
            sepcify controller and action. Anything in between specifys a sub
            package structure.<example>
                <title>Some FLOW3 CLI command specifications</title>

                <para><literal>testing cli run</literal> would call the "run"
                action of the "cli" controller in the "Testing" package</para>

                <para><literal>typo3cr admin setup default</literal> would
                call the "setup" controller's "default" action in the
                subpackage "admin" of the package "TYPO3CR"</para>
              </example></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>options</term>

          <listitem>
            <para>Options are either short- or long-style. The first option
            detected ends collecting command parts. Here are some
            examples:<example>
                <title>Giving options to FLOW3 CLI requests</title>

                <para><literal>-o -f=value --a-long-option --with-spaces="is
                possible" --input file1 -o=file2 --event-this =
                works</literal></para>
              </example></para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>arguments</term>

          <listitem>
            <para>Arguments can follow and will be available to the called
            controller in the request object. To distinguish between
            <replaceable>command</replaceable> and
            <replaceable>arguments</replaceable> in cases where no
            <replaceable>options</replaceable> are given the seperator
            <literal>--</literal> must be used.</para>
          </listitem>
        </varlistentry>
      </variablelist></para>

    <example>
      <title>Some FLOW3 CLI commands</title>

      <para>Calling the TYPO3CR setup:</para>

      <para><code>php index.php typo3cr admin setup setup
      --dsn=sqlite:/tmp/typo3cr.db --indexlocation=/tmp/lucene/</code></para>

      <para>Running FLOW3 unit tests:</para>

      <para><code>php index.php testing cli run --package-key=FLOW3
      --output-directory=./</code></para>

      <para>Rendering the FLOW3 documentation to HTML:</para>

      <para><code>php index.php doctools render render -p FLOW3 -o
      flow3-manual/</code></para>
    </example>
  </section>
</chapter>